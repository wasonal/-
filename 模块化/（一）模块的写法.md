#（一）模块的写法
## 背景
网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等......开发者不得不使用软件工程的方法，管理网页的业务逻辑。

Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。

但是，Javascript不是一种模块化编程语言，它不支持"类"（class），更遑论"模块"（module）了。（正在制定中的ECMAScript标准第六版，将正式支持"类"和"模块"，但还需要很长时间才能投入实用。）   
模块就是实现特定功能的一组方法。   
只要把不同的函数（以及记录状态的变量）简单放在一起，就算是一个模块。
## 原始写法
```
function m1(){
    //...
}

function m2(){
　　//...
}
```
上面的两个函数m1()和m2()组成一个模块。使用的时候直接调用就行了。   
但是这种做法的缺点很明显："污染了全局"，我们无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。
## 对象写法
为了解决上面的缺点，我们把模块写成一个对象，所有的模块成员都放进这个对象里面。
```
var module1 = new Object({
    _count : 0,
    m1: function(){
        //...
    },
    m2: function(){
        //...
    }
});
```
这样，我们就把函数m1()和m2()都哦封装到module1对象里了。使用的时候，就是调用这个对象的属性。
```
module1.m1();
```
但是这样的写法会暴露所有的模块成员，内部的状态可以直接被外部改写。比如，外部代码可以直接改写内部计数器的值。
```
module1._count = 5;
```
## 立即执行函数写法(IIFE)
```
var module1 = (function(){
    _count = 0;
    var m1 = function(){
        //...
    };
    var m2 = function(){
        //...
    };
    return {
        m1: m1,
        m2: m2
    };
})();
```
这样，外部代码就无法读取内部的_count变量了，达到不暴露私有成员的目的。
```
console.log(module1._count);//undefined
```
这种模式就是JavaScript模块的基本写法了。下面我们在对这种写法进行加工。
## 放大模式
如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用"放大模式"
```
var module1 = (function(mod){
    mod.m3 = function(){
        //...
    };
})(module1);
```
上面的代码为module1模块添加了一个新的方法，然后返回了添加m3后的module1模块。
## 宽放大模式
在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用"宽放大模式"。
```
var module1 = ( function (mod){
　　//...
　　return mod;
})(window.module1 || {});
```
与"放大模式"相比，"宽放大模式"就是IIFE的参数可以是空对象